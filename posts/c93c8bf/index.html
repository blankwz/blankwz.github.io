<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>容器Docker教程 | Gxkon's Blog</title><meta name="description" content="容器Docker教程 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。  一、介绍1. 容器发展历"><meta name="keywords" content="Docker"><meta name="author" content="Gkon"><meta name="copyright" content="Gkon"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="容器Docker教程"><meta name="twitter:description" content="容器Docker教程 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。  一、介绍1. 容器发展历"><meta name="twitter:image" content="http://gxkon.top/Pic/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="容器Docker教程"><meta property="og:url" content="http://gxkon.top/posts/c93c8bf/"><meta property="og:site_name" content="Gxkon's Blog"><meta property="og:description" content="容器Docker教程 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。  一、介绍1. 容器发展历"><meta property="og:image" content="http://gxkon.top/Pic/post.jpg"><meta property="article:published_time" content="2020-10-05T10:05:01.000Z"><meta property="article:modified_time" content="2020-10-06T09:27:35.432Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://gxkon.top/posts/c93c8bf/"><link rel="prev" title="Python之读取yaml配置文件" href="http://gxkon.top/posts/263918de/"><link rel="next" title="Docker简易封装Flask  +Gunicorn" href="http://gxkon.top/posts/e7e52c2a/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"本人,超帅,打钱","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/Pic/avatar.png" onerror="onerror=null;src='/Pic/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">96</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">65</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">45</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#容器Docker教程"><span class="toc-text">容器Docker教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、介绍"><span class="toc-text">一、介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-容器"><span class="toc-text">1. 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#发展历史"><span class="toc-text">发展历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器解决了什么"><span class="toc-text">容器解决了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是容器"><span class="toc-text">什么是容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器和虚拟机的区别-（可以两个一起使用）"><span class="toc-text">容器和虚拟机的区别 （可以两个一起使用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#出名的两种容器"><span class="toc-text">出名的两种容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#适合人群"><span class="toc-text">适合人群</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Docker的应用场景"><span class="toc-text">2. Docker的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Docker-架构"><span class="toc-text">3. Docker 架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、安装"><span class="toc-text">二、安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#几种系统平台安装"><span class="toc-text">几种系统平台安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结："><span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#国内-Docker-镜像加速"><span class="toc-text">国内 Docker 镜像加速</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ubuntu16-04-、Debian8-、CentOS7"><span class="toc-text">Ubuntu16.04+、Debian8+、CentOS7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ubuntu14-04、Debian7Wheezy"><span class="toc-text">Ubuntu14.04、Debian7Wheezy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通过修改启动脚本配置加速站点"><span class="toc-text">通过修改启动脚本配置加速站点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Docker使用"><span class="toc-text">三、Docker使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-容器使用"><span class="toc-text">1. 容器使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端命令查询"><span class="toc-text">客户端命令查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器查询-docker-ps"><span class="toc-text">容器查询 docker ps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取镜像-docker-pull"><span class="toc-text">获取镜像 docker pull</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#启动容器-docker-run"><span class="toc-text">启动容器  docker run</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#启动已停止运行的容器-docker-start"><span class="toc-text">启动已停止运行的容器  docker start</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#后台运行-d"><span class="toc-text">后台运行 -d</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#停止一个容器-docker-stop"><span class="toc-text">停止一个容器 docker stop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进入启动后的容器"><span class="toc-text">进入启动后的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#导出和导入容器-docker-export-与-docker-import"><span class="toc-text">导出和导入容器 docker export 与 docker import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除容器-docker-rm"><span class="toc-text">删除容器 docker rm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器命名-–name"><span class="toc-text">容器命名 –name</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Web应用实例"><span class="toc-text">2. Web应用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#运行一个-web-应用"><span class="toc-text">运行一个 web 应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看-WEB-应用容器"><span class="toc-text">查看 WEB 应用容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#网络端口的快捷方式-docker-port"><span class="toc-text">网络端口的快捷方式 docker port</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看-WEB-应用程序日志-docker-logs"><span class="toc-text">查看 WEB 应用程序日志  docker logs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看WEB应用程序容器的进程-docker-top"><span class="toc-text">查看WEB应用程序容器的进程 docker top</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#检查-WEB-应用程序-docker-inspect"><span class="toc-text">检查 WEB 应用程序 docker inspect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#停止重启移除-WEB-应用容器"><span class="toc-text">停止重启移除 WEB 应用容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-镜像使用"><span class="toc-text">3. 镜像使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#列出镜像列表-docker-images"><span class="toc-text">列出镜像列表 docker images</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取一个新的镜像-docker-pull"><span class="toc-text">获取一个新的镜像 docker pull</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查找镜像-docker-search"><span class="toc-text">查找镜像 docker search</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除镜像-docker-rmi"><span class="toc-text">删除镜像 docker rmi</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建镜像"><span class="toc-text">创建镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置镜像标签-docker-tag"><span class="toc-text">设置镜像标签 docker tag</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-容器连接"><span class="toc-text">4. 容器连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#网络端口映射"><span class="toc-text">网络端口映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-容器互联"><span class="toc-text">Docker 容器互联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#新建网络-docker-network-create"><span class="toc-text">新建网络 docker network create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#连接容器"><span class="toc-text">连接容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试是否互联"><span class="toc-text">测试是否互联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-DNS"><span class="toc-text">配置 DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#设置全部容器的-DNS"><span class="toc-text">设置全部容器的 DNS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#指定单个容器的DNS"><span class="toc-text">指定单个容器的DNS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-仓库管理"><span class="toc-text">5. 仓库管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、创建镜像"><span class="toc-text">四、创建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#更新（修改）镜像"><span class="toc-text">更新（修改）镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建镜像-Dockerfile"><span class="toc-text">构建镜像 Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注意事项："><span class="toc-text">注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile指令详解"><span class="toc-text">Dockerfile指令详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RUN-build时运行"><span class="toc-text">RUN - build时运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COPY-复制文件"><span class="toc-text">COPY 复制文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ADD"><span class="toc-text">ADD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMD-run时运行"><span class="toc-text">CMD - run时运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ENTRYPOINT-指定参数"><span class="toc-text">ENTRYPOINT - 指定参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ENV-环境变量"><span class="toc-text">ENV - 环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARG-build时的环境变量"><span class="toc-text">ARG - build时的环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VOLUME-挂载点"><span class="toc-text">VOLUME - 挂载点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXPOSE-端口"><span class="toc-text">EXPOSE - 端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WORKDIR-工作目录"><span class="toc-text">WORKDIR - 工作目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#USER-用户"><span class="toc-text">USER  - 用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HEALTHCHECK-运行状态"><span class="toc-text">HEALTHCHECK - 运行状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ONBUILD-延迟构建命令的执行"><span class="toc-text">ONBUILD - 延迟构建命令的执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、Docker-Compose"><span class="toc-text">五、Docker Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Compose-使用的三个步骤："><span class="toc-text">Compose 使用的三个步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compose-安装"><span class="toc-text">Compose 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compose-实例"><span class="toc-text">Compose 实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yml-配置指令参考"><span class="toc-text">yml 配置指令参考</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#version"><span class="toc-text">version</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#build"><span class="toc-text">build</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cap-add，cap-drop"><span class="toc-text">cap_add，cap_drop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cgroup-parent"><span class="toc-text">cgroup_parent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#command"><span class="toc-text">command</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#container-name"><span class="toc-text">container_name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#depends-on"><span class="toc-text">depends_on</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deploy"><span class="toc-text">deploy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#devices"><span class="toc-text">devices</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dns"><span class="toc-text">dns</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dns-search"><span class="toc-text">dns_search</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#entrypoint"><span class="toc-text">entrypoint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#env-file"><span class="toc-text">env_file</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#environment"><span class="toc-text">environment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#expose"><span class="toc-text">expose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extra-hosts"><span class="toc-text">extra_hosts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#healthcheck"><span class="toc-text">healthcheck</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#image"><span class="toc-text">image</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#logging"><span class="toc-text">logging</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#network-mode"><span class="toc-text">network_mode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#restart"><span class="toc-text">restart</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#secrets"><span class="toc-text">secrets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#security-opt"><span class="toc-text">security_opt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stop-grace-period"><span class="toc-text">stop_grace_period</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stop-signal"><span class="toc-text">stop_signal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sysctls"><span class="toc-text">sysctls</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tmpfs"><span class="toc-text">tmpfs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ulimits"><span class="toc-text">ulimits</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volumes"><span class="toc-text">volumes</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、Docker-Machine"><span class="toc-text">六、Docker Machine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安装"><span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-安装命令"><span class="toc-text">Linux 安装命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#macOS-安装命令"><span class="toc-text">macOS 安装命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令参数"><span class="toc-text">命令参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、Docker-Swarm-集群管理"><span class="toc-text">七、Docker Swarm  集群管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例"><span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、命令大全"><span class="toc-text">八、命令大全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#容器生命周期管理"><span class="toc-text">容器生命周期管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器操作"><span class="toc-text">容器操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器rootfs命令"><span class="toc-text">容器rootfs命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#镜像仓库"><span class="toc-text">镜像仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#本地镜像管理"><span class="toc-text">本地镜像管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#info-version"><span class="toc-text">info|version</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、其他问题"><span class="toc-text">九、其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#镜像中安装VIM、yum"><span class="toc-text">镜像中安装VIM、yum</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/Pic/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Gxkon's Blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">容器Docker教程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-10-05 18:05:01"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-10-05</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-10-06 17:27:35"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-10-06</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%BC%80%E5%8F%91%E5%BF%85%E4%BC%9A/">开发必会</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%BC%80%E5%8F%91%E5%BF%85%E4%BC%9A/Docker/">Docker</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/posts/c93c8bf/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="容器Docker教程"><a href="#容器Docker教程" class="headerlink" title="容器Docker教程"></a>容器Docker教程</h1><blockquote>
<p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a> 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
</blockquote>
<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><h3 id="1-容器"><a href="#1-容器" class="headerlink" title="1. 容器"></a>1. 容器</h3><h4 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h4><ol>
<li><code>没出现容器技术前</code><ol>
<li>部署非常慢</li>
<li>成本非常高</li>
<li>资源浪费</li>
<li>难于迁移和扩展</li>
<li>可能会被限定硬件厂商</li>
</ol>
</li>
<li><code>虚拟化技术出现</code><ol>
<li>一个物理机可以部署多个app</li>
<li>每个app独立运行在一个 <code>虚拟机vm</code> 中</li>
<li>局限性<ul>
<li>每个虚拟机都是一个完整的操作系统，要给其分配资源，当虚拟机数量增多时，操作系统本身消耗的资源势必增多</li>
</ul>
</li>
</ol>
</li>
<li><code>容器技术出现</code></li>
</ol>
<h4 id="容器解决了什么"><a href="#容器解决了什么" class="headerlink" title="容器解决了什么"></a>容器解决了什么</h4><ol>
<li>打包app，打包好的app可以运行在很多主流操作系统上</li>
<li>解决了开发与运维之间的矛盾</li>
</ol>
<h4 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h4><ul>
<li><p>对软件和其依赖的标准化打包</p>
</li>
<li><p>应用之间相互隔离</p>
</li>
<li><p>共享同一个OS kernel</p>
</li>
<li><p>可以运行在很多主流操作系统上</p>
</li>
</ul>
<h4 id="容器和虚拟机的区别-（可以两个一起使用）"><a href="#容器和虚拟机的区别-（可以两个一起使用）" class="headerlink" title="容器和虚拟机的区别 （可以两个一起使用）"></a>容器和虚拟机的区别 （可以两个一起使用）</h4><ol>
<li><p>隔离</p>
<ul>
<li><p>容器是app层面的隔离</p>
</li>
<li><p>虚拟化是物理资源层面的隔离</p>
</li>
</ul>
</li>
<li><p>系统</p>
<ul>
<li>容器共享同一个系统</li>
<li>虚拟化是多个系统</li>
</ul>
</li>
</ol>
<h4 id="出名的两种容器"><a href="#出名的两种容器" class="headerlink" title="出名的两种容器"></a>出名的两种容器</h4><ol>
<li>Docker</li>
<li>K8s </li>
</ol>
<h4 id="适合人群"><a href="#适合人群" class="headerlink" title="适合人群"></a>适合人群</h4><ol>
<li>开发人员</li>
<li>测试人员</li>
<li>运维人员</li>
</ol>
<h3 id="2-Docker的应用场景"><a href="#2-Docker的应用场景" class="headerlink" title="2. Docker的应用场景"></a>2. Docker的应用场景</h3><ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>
<h3 id="3-Docker-架构"><a href="#3-Docker-架构" class="headerlink" title="3. Docker 架构"></a>3. Docker 架构</h3><p><strong>Docker 包括三个基本概念:</strong></p>
<ul>
<li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</p>
<p>Docker 容器通过 Docker 镜像来创建。</p>
<p>容器与镜像的关系类似于面向对象编程中的对象与类</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Docker 镜像(Images)</td>
<td align="left">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td align="left">Docker 容器(Container)</td>
<td align="left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td align="left">Docker 客户端(Client)</td>
<td align="left">Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td align="left">Docker 主机(Host)</td>
<td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="left">Docker Registry</td>
<td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td>
</tr>
<tr>
<td align="left">Docker Machine</td>
<td align="left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody></table>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><blockquote>
<p> <a href="https://www.docker.com/get-started" target="_blank" rel="noopener">官网下载</a> (搭梯子下载更快)</p>
<p><a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">官网文档</a></p>
<p>建议不要在Windows和Mac下学习，玩Dokcer。</p>
<p>建议在虚拟机下学习~方便后面的删除等等</p>
</blockquote>
<h3 id="几种系统平台安装"><a href="#几种系统平台安装" class="headerlink" title="几种系统平台安装"></a>几种系统平台安装</h3><p>各系统平台安装详细看<a href="https://docs.docker.com/engine/install/" target="_blank" rel="noopener">官网</a></p>
<ul>
<li><p>Linux Docker安装 </p>
<ul>
<li>Ubuntu Docker 安装</li>
<li>Debian Docker 安装</li>
<li>CentOS Docker 安装</li>
</ul>
</li>
<li><p>Windows Docker 安装：<a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">详情</a></p>
</li>
<li><p>MacOS Docker 安装：<a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="noopener">详情</a></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CentOS</span></span><br><span class="line"><span class="comment"># 安装yum-utils软件包（提供yum-config-manager 实用程序）并设置稳定的存储库。</span></span><br><span class="line">$ sudo yum install -y yum-utils</span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line"><span class="comment">#安装最新版本的Docker Engine和容器 </span></span><br><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="comment">#启动Docker</span></span><br><span class="line">$ sudo systemctl start docker</span><br><span class="line"><span class="comment">#通过运行hello-world 映像来验证是否正确安装了Docker Engine 。</span></span><br><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>



<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>在Windows和Mac下，直接安装Doker安装包</li>
<li>在虚拟机中，安装Linux系统，然后在Linux系统中安装Docker<ul>
<li>可通过Vagrant<code>安装到</code>Virtual Box` （不用下镜像，通过Vagrant配置文件直接可以指定系统，自动下载到VB中）<ul>
<li>Windows和Mac上都有 <code>Vagrant</code>和<code>Virtual Box</code></li>
<li>可以通过网络上的Vagrant File配置和创建系统</li>
</ul>
</li>
</ul>
</li>
<li>通过<code>Docker Machine</code>安装一个迷你的<code>已安装好Docker的linux系统</code>（安装过Docker就会有<code>DM</code>，或者独立安装<code>DM</code>）<ol>
<li>在本地机子上使用 DM</li>
<li>在阿里云上使用</li>
<li>在亚马逊AWS云上使用</li>
<li>等等</li>
</ol>
</li>
</ol>
<h3 id="国内-Docker-镜像加速"><a href="#国内-Docker-镜像加速" class="headerlink" title="国内 Docker 镜像加速"></a>国内 Docker 镜像加速</h3><p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务</p>
<ul>
<li>阿里云：<strong>https://&lt;你的ID&gt;.mirror.aliyuncs.com</strong><ul>
<li><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">阿里云镜像获取地址</a>登陆后，左侧菜单选中镜像加速器就可以看到你的专属地址了</li>
</ul>
</li>
<li>七牛云加速器：<strong><a href="https://reg-mirror.qiniu.com" target="_blank" rel="noopener">https://reg-mirror.qiniu.com</a></strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">阿里云的加速器：https://help.aliyun.com/document_detail/60750.html</span><br><span class="line">网易加速器：http://hub-mirror.c.163.com</span><br><span class="line">官方中国加速器：https://registry.docker-cn.com</span><br><span class="line">ustc 的镜像：https://docker.mirrors.ustc.edu.cn</span><br><span class="line">daocloud：https://www.daocloud.io/mirror<span class="comment">#accelerator-doc（注册后使用）</span></span><br></pre></td></tr></table></figure>



<h4 id="Ubuntu16-04-、Debian8-、CentOS7"><a href="#Ubuntu16-04-、Debian8-、CentOS7" class="headerlink" title="Ubuntu16.04+、Debian8+、CentOS7"></a>Ubuntu16.04+、Debian8+、CentOS7</h4><p>对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># vi /etc/docker/daemon.json</span></span><br><span class="line">&#123;<span class="string">"registry-mirrors"</span>: [<span class="string">"http://hub-mirror.c.163.com"</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者 。。。</span></span><br><span class="line">&#123;<span class="string">"registry-mirrors"</span>:[<span class="string">"https://reg-mirror.qiniu.com/"</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新启动服务：</span></span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="Ubuntu14-04、Debian7Wheezy"><a href="#Ubuntu14-04、Debian7Wheezy" class="headerlink" title="Ubuntu14.04、Debian7Wheezy"></a>Ubuntu14.04、Debian7Wheezy</h4><p>对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中配置加速器地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">"--registry-mirror=https://registry.docker-cn.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重新启动服务:</span></span><br><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure>

<h4 id="通过修改启动脚本配置加速站点"><a href="#通过修改启动脚本配置加速站点" class="headerlink" title="通过修改启动脚本配置加速站点"></a><strong>通过修改启动脚本配置加速站点</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接修改 /usr/lib/systemd/system/docker.service 启动脚本</span></span><br><span class="line">vim /usr/lib/systemd/system/docker.service </span><br><span class="line"><span class="comment"># 在dockerd后面加参数</span></span><br><span class="line">ExecStart=/usr/bin/dockerd --registry-mirror=&lt;your accelerate address&gt;</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>



<h2 id="三、Docker使用"><a href="#三、Docker使用" class="headerlink" title="三、Docker使用"></a>三、Docker使用</h2><h3 id="1-容器使用"><a href="#1-容器使用" class="headerlink" title="1. 容器使用"></a>1. 容器使用</h3><h4 id="客户端命令查询"><a href="#客户端命令查询" class="headerlink" title="客户端命令查询"></a><strong>客户端命令查询</strong></h4><ol>
<li>直接输入 <code>docker</code> 命令来查看到 Docker 客户端的所有命令选项</li>
<li><strong>docker command –help</strong> 更深入的了解某个指定的 Docker 命令使用方法</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker</span><br><span class="line">$ docker stats --<span class="built_in">help</span>  <span class="comment"># 查看 docker stats 指令的具体使用方法</span></span><br></pre></td></tr></table></figure>

<h4 id="容器查询-docker-ps"><a href="#容器查询-docker-ps" class="headerlink" title="容器查询 docker ps"></a>容器查询 docker ps</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有的容器</span></span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ docker ps [OPTIONS]</span><br><span class="line">OPTIONS说明：</span><br><span class="line">-a :显示所有的容器，包括未运行的。</span><br><span class="line">-f :根据条件过滤显示的内容。</span><br><span class="line">--format :指定返回值的模板文件。</span><br><span class="line">-l :显示最近创建的容器。</span><br><span class="line">-n :列出最近创建的n个容器。</span><br><span class="line">--no-trunc :不截断输出。</span><br><span class="line">-q :静默模式，只显示容器编号。</span><br><span class="line">-s :显示总的文件大小。</span><br></pre></td></tr></table></figure>



<h4 id="获取镜像-docker-pull"><a href="#获取镜像-docker-pull" class="headerlink" title="获取镜像 docker pull"></a>获取镜像 docker pull</h4><p>如果我们本地没有xxxx 镜像，我们可以使用 <code>docker pull</code> 命令来载入 xxx 镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如需要ubuntu 镜像</span></span><br><span class="line">$ docker pull ubuntu</span><br></pre></td></tr></table></figure>

<h4 id="启动容器-docker-run"><a href="#启动容器-docker-run" class="headerlink" title="启动容器  docker run"></a>启动容器  docker run</h4><p>使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器</p>
<ul>
<li>要退出终端，直接输入 <code>exit</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu /bin/bash</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">-i: 交互式操作。</span><br><span class="line">-t: 终端。</span><br><span class="line">ubuntu: ubuntu 镜像。</span><br><span class="line">/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</span><br></pre></td></tr></table></figure>

<h4 id="启动已停止运行的容器-docker-start"><a href="#启动已停止运行的容器-docker-start" class="headerlink" title="启动已停止运行的容器  docker start"></a>启动已停止运行的容器  docker start</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先查看所有的容器，查看 容器ID</span></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">docker start  容器ID</span><br></pre></td></tr></table></figure>

<h4 id="后台运行-d"><a href="#后台运行-d" class="headerlink" title="后台运行 -d"></a>后台运行 -d</h4><p>希望 docker 的服务是在后台运行的，我们可以过 <strong>-d</strong> 指定容器的运行模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name ubuntu-test ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="停止一个容器-docker-stop"><a href="#停止一个容器-docker-stop" class="headerlink" title="停止一个容器 docker stop"></a>停止一个容器 docker stop</h4><ul>
<li>停止的容器可以通过 docker restart 重启</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;容器 ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">docker restart &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>

<h4 id="进入启动后的容器"><a href="#进入启动后的容器" class="headerlink" title="进入启动后的容器"></a>进入启动后的容器</h4><p>在使用 <strong>-d</strong> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
<ul>
<li><strong>docker attach</strong> &lt;容器 ID&gt;<ul>
<li>如果从这个容器退出，会导致容器的停止</li>
</ul>
</li>
<li>*<em>docker exec *</em>&lt;容器 ID&gt;：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。<ul>
<li>更多参数说明请使用 <strong>docker exec –help</strong> 命令查看</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach 1e560fca3906 </span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 243c32535da7 /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="导出和导入容器-docker-export-与-docker-import"><a href="#导出和导入容器-docker-export-与-docker-import" class="headerlink" title="导出和导入容器 docker export 与 docker import"></a>导出和导入容器 <strong>docker export</strong> 与 docker import</h4><ul>
<li>如果要导出本地某个容器，可以使用 <strong>docker export</strong> 命令<ul>
<li>导出容器快照到本地文件</li>
</ul>
</li>
<li>使用 docker import 导入为镜像<ul>
<li>可以导入本地文件</li>
<li>也可以通过指定 URL 或者某个目录来导入</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出容器 1e560fca3906 快照到本地文件 ubuntu.tar</span></span><br><span class="line">$ docker <span class="built_in">export</span> 1e560fca3906 &gt; ubuntu.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:</span></span><br><span class="line">$ cat docker/ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 URL 或者某个目录来导入</span></span><br><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>

<h4 id="删除容器-docker-rm"><a href="#删除容器-docker-rm" class="headerlink" title="删除容器 docker rm"></a>删除容器 <strong>docker rm</strong></h4><p>删除容器时，容器必须是停止状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm -f 1e560fca3906</span><br></pre></td></tr></table></figure>

<h4 id="容器命名-–name"><a href="#容器命名-–name" class="headerlink" title="容器命名 –name"></a>容器命名 <strong>–name</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P --name runoob training/webapp python app.py</span><br><span class="line">$ docker ps -l</span><br><span class="line">CONTAINER ID     IMAGE            COMMAND           ...    PORTS                     NAMES</span><br><span class="line">43780a6eabaa     training/webapp   <span class="string">"python app.py"</span>  ...     0.0.0.0:32769-&gt;5000/tcp   runoob</span><br></pre></td></tr></table></figure>



<h3 id="2-Web应用实例"><a href="#2-Web应用实例" class="headerlink" title="2. Web应用实例"></a>2. Web应用实例</h3><p>使用 docker 构建一个 web 应用程序。</p>
<p>我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用</p>
<h4 id="运行一个-web-应用"><a href="#运行一个-web-应用" class="headerlink" title="运行一个 web 应用"></a>运行一个 web 应用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull training/webapp  <span class="comment"># 载入镜像</span></span><br><span class="line">$ docker run -d -P training/webapp python app.py</span><br><span class="line"></span><br><span class="line">-d:让容器在后台运行。</span><br><span class="line">-P:将容器内部使用的网络端口随机映射到我们使用的主机上。</span><br></pre></td></tr></table></figure>

<h4 id="查看-WEB-应用容器"><a href="#查看-WEB-应用容器" class="headerlink" title="查看 WEB 应用容器"></a>查看 WEB 应用容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 docker ps 来查看我们正在运行的容器</span></span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             ...        PORTS                 </span><br><span class="line">d3d5e39ed9d3        training/webapp     <span class="string">"python app.py"</span>     ...        0.0.0.0:32769-&gt;5000/tcp</span><br><span class="line"></span><br><span class="line">多了端口信息:0.0.0.0:32769-&gt;5000/tcp</span><br><span class="line">Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 -p 参数来设置不一样的端口</span></span><br><span class="line">$ docker run -d -p 5000:5000 training/webapp python app.py  <span class="comment"># 容器内部的 5000 端口映射到我们本地主机的 5000 端口上</span></span><br></pre></td></tr></table></figure>

<h4 id="网络端口的快捷方式-docker-port"><a href="#网络端口的快捷方式-docker-port" class="headerlink" title="网络端口的快捷方式 docker port"></a>网络端口的快捷方式 <strong>docker port</strong></h4><p>使用 <strong>docker port</strong> 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port 容器ID</span><br><span class="line">$ docker port 容器名称</span><br></pre></td></tr></table></figure>

<h4 id="查看-WEB-应用程序日志-docker-logs"><a href="#查看-WEB-应用程序日志-docker-logs" class="headerlink" title="查看 WEB 应用程序日志  docker logs"></a>查看 WEB 应用程序日志  docker logs</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以查看容器内部的标准输出</span></span><br><span class="line">$ docker logs [ID或者名字]</span><br></pre></td></tr></table></figure>

<h4 id="查看WEB应用程序容器的进程-docker-top"><a href="#查看WEB应用程序容器的进程-docker-top" class="headerlink" title="查看WEB应用程序容器的进程 docker top"></a>查看WEB应用程序容器的进程 docker top</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器内部运行的进程</span></span><br><span class="line">$ docker top [ID或者名字]</span><br></pre></td></tr></table></figure>

<h4 id="检查-WEB-应用程序-docker-inspect"><a href="#检查-WEB-应用程序-docker-inspect" class="headerlink" title="检查 WEB 应用程序 docker inspect"></a>检查 WEB 应用程序 <strong>docker inspect</strong></h4><p>使用 <strong>docker inspect</strong> 来查看 Docker 的底层信息。</p>
<ul>
<li>它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect [ID或者名字] </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"bf08b7f2cd897b5964943134aa6d373e355c286db9b9885b1f60b6e8f82b2b85"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2018-09-17T01:41:26.174228707Z"</span>,</span><br><span class="line">        <span class="string">"Path"</span>: <span class="string">"python"</span>,</span><br><span class="line">        <span class="string">"Args"</span>: [</span><br><span class="line">            <span class="string">"app.py"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"State"</span>: &#123;</span><br><span class="line">            <span class="string">"Status"</span>: <span class="string">"running"</span>,</span><br><span class="line">            <span class="string">"Running"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"Paused"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Restarting"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"OOMKilled"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Dead"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Pid"</span>: 23245,</span><br><span class="line">            <span class="string">"ExitCode"</span>: 0,</span><br><span class="line">            <span class="string">"Error"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"StartedAt"</span>: <span class="string">"2018-09-17T01:41:26.494185806Z"</span>,</span><br><span class="line">            <span class="string">"FinishedAt"</span>: <span class="string">"0001-01-01T00:00:00Z"</span></span><br><span class="line">        &#125;,</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h4 id="停止重启移除-WEB-应用容器"><a href="#停止重启移除-WEB-应用容器" class="headerlink" title="停止重启移除 WEB 应用容器"></a>停止重启移除 WEB 应用容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">$ docker stop [ID或者名字] </span><br><span class="line"><span class="comment"># 启动已经停止的容器</span></span><br><span class="line">docker start [ID或者名字] </span><br><span class="line"><span class="comment"># 重启运行中的容器</span></span><br><span class="line">docker restart [ID或者名字] </span><br><span class="line"><span class="comment"># 移除容器  （删除容器时，容器必须是停止状态）</span></span><br><span class="line">docker rm [ID或者名字]</span><br></pre></td></tr></table></figure>

<h3 id="3-镜像使用"><a href="#3-镜像使用" class="headerlink" title="3. 镜像使用"></a>3. 镜像使用</h3><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 公共镜像源下载</p>
<h4 id="列出镜像列表-docker-images"><a href="#列出镜像列表-docker-images" class="headerlink" title="列出镜像列表 docker images"></a>列出镜像列表 <strong>docker images</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker images       </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB</span><br><span class="line"></span><br><span class="line">各个选项说明:</span><br><span class="line"></span><br><span class="line">REPOSITORY：表示镜像的仓库源</span><br><span class="line">TAG：镜像的标签</span><br><span class="line">IMAGE ID：镜像ID</span><br><span class="line">CREATED：镜像创建时间</span><br><span class="line">SIZE：镜像大小</span><br></pre></td></tr></table></figure>

<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本</p>
<p>我们使用 REPOSITORY:TAG 来定义不同的镜像</p>
<ul>
<li>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要使用版本为15.10的ubuntu系统镜像来运行容器时</span></span><br><span class="line">$ docker run -t -i ubuntu:15.10 /bin/bash </span><br><span class="line"><span class="comment"># 使用版本为 14.04 的 ubuntu 系统镜像来运行容器时</span></span><br><span class="line">docker run -t -i ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="获取一个新的镜像-docker-pull"><a href="#获取一个新的镜像-docker-pull" class="headerlink" title="获取一个新的镜像 docker pull"></a>获取一个新的镜像 docker pull</h4><p>我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。</p>
<p>如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>
<ul>
<li>下载完成后，我们可以直接使用这个镜像来运行容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:13.10</span><br></pre></td></tr></table></figure>

<h4 id="查找镜像-docker-search"><a href="#查找镜像-docker-search" class="headerlink" title="查找镜像 docker search"></a>查找镜像 docker search</h4><ul>
<li>可以从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 网站来搜索镜像</li>
<li>也可以使用 docker search 命令来搜索镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索一个 httpd 的镜像来作为我们的 web 服务</span></span><br><span class="line">$  docker search httpd</span><br><span class="line"></span><br><span class="line">NAME: 镜像仓库源的名称</span><br><span class="line">DESCRIPTION: 镜像的描述</span><br><span class="line">OFFICIAL: 是否 docker 官方发布</span><br><span class="line">stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</span><br><span class="line">AUTOMATED: 自动构建</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后拉取镜像</span></span><br><span class="line">$ docker pull httpd</span><br><span class="line"><span class="comment"># 下载完成后，我们就可以使用这个镜像了</span></span><br><span class="line">$ docker run httpd</span><br></pre></td></tr></table></figure>

<h4 id="删除镜像-docker-rmi"><a href="#删除镜像-docker-rmi" class="headerlink" title="删除镜像 docker rmi"></a>删除镜像 <strong>docker rmi</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 hello-world 镜像</span></span><br><span class="line">$ docker rmi hello-world</span><br></pre></td></tr></table></figure>

<h4 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h4><p>看[下面](#五、创建镜像 - DockerFile)</p>
<h4 id="设置镜像标签-docker-tag"><a href="#设置镜像标签-docker-tag" class="headerlink" title="设置镜像标签 docker tag"></a>设置镜像标签 docker tag</h4><p>为本地镜像多添加一个标签</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag 860c279d2fec runoob/centos:dev</span><br></pre></td></tr></table></figure>

<h3 id="4-容器连接"><a href="#4-容器连接" class="headerlink" title="4. 容器连接"></a>4. 容器连接</h3><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <strong>-P</strong> 或 <strong>-p</strong> 参数来指定端口映射</p>
<h4 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h4><ul>
<li><strong>-P :</strong>是容器内部端口<strong>随机</strong>映射到主机的高端口。</li>
<li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建了一个 python 应用的容器</span></span><br><span class="line">$ docker run -d -P training/webapp python app.py  <span class="comment"># 随机到高端口</span></span><br><span class="line">$ docker run -d -p 5000:5000 training/webapp python app.py  <span class="comment"># 指定端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定的指定网络地址</span></span><br><span class="line">$ docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定 UDP 端口，端口后面加上 /udp  （默认都是绑定 tcp 端口）</span></span><br><span class="line">$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看端口的绑定情况</span></span><br><span class="line">docker port id/名字 5000</span><br></pre></td></tr></table></figure>

<h4 id="Docker-容器互联"><a href="#Docker-容器互联" class="headerlink" title="Docker 容器互联"></a>Docker 容器互联</h4><p>端口映射并不是唯一把 docker 连接到另一个容器的方法。</p>
<ul>
<li><p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</p>
</li>
<li><p>docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</p>
</li>
</ul>
<h4 id="新建网络-docker-network-create"><a href="#新建网络-docker-network-create" class="headerlink" title="新建网络 docker network create"></a>新建网络 docker network create</h4><p>创建一个新的 Docker 网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge <span class="built_in">test</span>-net</span><br><span class="line">$ docker network ls  查看网络</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-d：参数指定 Docker 网络类型，有 bridge、overlay。</span><br><span class="line">其中 overlay 网络类型用于 Swarm mode</span><br></pre></td></tr></table></figure>

<h4 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h4><p>有多个容器之间需要互相连接，推荐使用 Docker Compose</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行一个容器并连接到新建的 test-net 网络</span></span><br><span class="line">$ docker run -itd --name test1 --network <span class="built_in">test</span>-net ubuntu /bin/bash</span><br><span class="line"><span class="comment"># 打开新的终端，再运行一个容器并加入到 test-net 网络:</span></span><br><span class="line">$ docker run -itd --name test2 --network <span class="built_in">test</span>-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="测试是否互联"><a href="#测试是否互联" class="headerlink" title="测试是否互联"></a>测试是否互联</h4><p>通过 ping 来证明 test1 容器和 test2 容器建立了互联关系</p>
<ul>
<li>如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping</li>
<li>可以在一个容器里安装好，提交容器到镜像，再以新的镜像重新运行以上俩个容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">apt-get update</span><br><span class="line">apt install iputils-ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 test1 容器输入以下命令</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it test1 /bin/bash</span><br><span class="line">ping test2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 test2 容器输入以下命令</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it test2 /bin/bash  <span class="comment"># 进入</span></span><br><span class="line">ping test1</span><br></pre></td></tr></table></figure>

<h4 id="配置-DNS"><a href="#配置-DNS" class="headerlink" title="配置 DNS"></a>配置 DNS</h4><h5 id="设置全部容器的-DNS"><a href="#设置全部容器的-DNS" class="headerlink" title="设置全部容器的 DNS"></a>设置全部容器的 DNS</h5><p>在宿主机的 /etc/docker/daemon.json 文件中增加以下内容</p>
<ul>
<li>配置完，需要重启 docker 才能生效 :  <code>/etc/init.d/docker restart</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"dns"</span> : [</span><br><span class="line">    <span class="string">"114.114.114.114"</span>,</span><br><span class="line">    <span class="string">"8.8.8.8"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器的 DNS 是否生效可以使用以下命令</span></span><br><span class="line">$ docker run -it --rm  ubuntu  cat etc/resolv.conf</span><br></pre></td></tr></table></figure>

<h5 id="指定单个容器的DNS"><a href="#指定单个容器的DNS" class="headerlink" title="指定单个容器的DNS"></a>指定单个容器的DNS</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm -h host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</span><br><span class="line"></span><br><span class="line">数说明：</span><br><span class="line"></span><br><span class="line">--rm：容器退出时自动清理容器内部的文件系统。</span><br><span class="line">-h HOSTNAME 或者 --hostname=HOSTNAME： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</span><br><span class="line">--dns=IP_ADDRESS： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</span><br><span class="line">--dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在容器启动时没有指定 --dns 和 --dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS</span></span><br></pre></td></tr></table></figure>



<h3 id="5-仓库管理"><a href="#5-仓库管理" class="headerlink" title="5. 仓库管理"></a>5. 仓库管理</h3><p>仓库（Repository）是集中存放镜像的地方。</p>
<ul>
<li>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a></li>
<li>当然不止 docker hub，只是远程的服务商不一样，操作都是一样的</li>
</ul>
<ol>
<li>在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">官网</a> 免费注册一个 Docker 账号</li>
<li>输入 <code>docker login</code> 登录（输入用户名和密码），登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像</li>
<li>登出命令 <code>docker logout</code></li>
<li>用户登录后，先通过 <code>docker tag</code>给本地镜像放入仓库 （必须，否则提示：<code>denied: requested access to the resource is denied</code>）</li>
<li>然后通过 <code>docker push</code> 命令将自己的镜像推送到 Docker Hub</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下命令中的 username 请替换为你的 Docker 账号用户名</span></span><br><span class="line"></span><br><span class="line">$ docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG        IMAGE ID            CREATED           ...  </span><br><span class="line">ubuntu          18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">username/ubuntu 18.04      275d79972a86        6 days ago        ...  </span><br><span class="line">$ docker push username/ubuntu:18.04</span><br><span class="line">$ docker search username/ubuntu</span><br><span class="line"></span><br><span class="line">NAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure>





<h2 id="四、创建镜像"><a href="#四、创建镜像" class="headerlink" title="四、创建镜像"></a>四、创建镜像</h2><p>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。</p>
<ul>
<li>1、从已经创建的容器中更新镜像，并且提交这个镜像</li>
<li>2、使用 Dockerfile 指令来创建一个新的镜像</li>
</ul>
<h3 id="更新（修改）镜像"><a href="#更新（修改）镜像" class="headerlink" title="更新（修改）镜像"></a>更新（修改）镜像</h3><ol>
<li>更新（修改）镜像之前，我们需要使用镜像来创建一个容器</li>
<li>在运行的容器内使用 <strong>apt-get update</strong> 命令进行更新 （或者其他的更新内容，自定义）</li>
<li>在完成操作之后，输入 exit 命令来退出这个容器</li>
<li>通过命令 docker commit 来提交容器副本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个容器</span></span><br><span class="line">$ docker run -t -i ubuntu:15.10 /bin/bash   <span class="comment"># 或者 docker run -it ubuntu:15.10 /bin/bash</span></span><br><span class="line"><span class="comment"># 更新 ,或者其他的更新内容，自定义</span></span><br><span class="line">$ apt-get update</span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">$ docker commit -m=<span class="string">"has update"</span> -a=<span class="string">"runoob"</span> e218edb10161 runoob/ubuntu:v2</span><br><span class="line"></span><br><span class="line">-m: 提交的描述信息</span><br><span class="line">-a: 指定镜像作者</span><br><span class="line">e218edb10161：容器 ID</span><br><span class="line">runoob/ubuntu:v2: 指定要创建的目标镜像名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用我们的新镜像 runoob/ubuntu 来启动一个容器</span></span><br><span class="line">$ docker run -t -i runoob/ubuntu:v2 /bin/bash</span><br></pre></td></tr></table></figure>



<h3 id="构建镜像-Dockerfile"><a href="#构建镜像-Dockerfile" class="headerlink" title="构建镜像 Dockerfile"></a>构建镜像 Dockerfile</h3><p>使用命令 <strong>docker build</strong> ， 从零开始来创建一个新的镜像。</p>
<ol>
<li>先创建一个 <code>Dockerfile</code> 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat Dockerfile  <span class="comment"># 建立Dockerfile文件</span></span><br><span class="line">FROM    centos:6.7</span><br><span class="line">MAINTAINER      Fisher <span class="string">"fisher@sudops.com"</span></span><br><span class="line"></span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> <span class="string">'root:123456'</span> |chpasswd</span><br><span class="line">RUN     useradd runoob</span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> <span class="string">'runoob:123456'</span> |chpasswd</span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> -e <span class="string">"LANG=\"en_US.UTF-8\""</span> &gt;/etc/default/<span class="built_in">local</span></span><br><span class="line">EXPOSE  22</span><br><span class="line">EXPOSE  80</span><br><span class="line">CMD     /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过 docker build 命令来构建一个镜像  （镜像名称:镜像标签）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t runoob/centos:6.7 .</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-t ：指定要创建的目标镜像名</span><br><span class="line">. ： 上下文路径，Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用docker images 查看创建的镜像已经在列表中存在</span></span><br><span class="line">$ docker images </span><br><span class="line"><span class="comment"># 使用新的镜像来创建容器</span></span><br><span class="line">$ docker run -t -i runoob/centos:6.7  /bin/bash</span><br></pre></td></tr></table></figure>



<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h4><ol>
<li>每一个指令的前缀都必须是大写的</li>
<li>上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢</li>
<li>Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大<ul>
<li>尽量少RUN，建议，多个命令拼接一起</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install wget</span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span></span><br><span class="line">RUN tar -xvf redis.tar.gz</span><br><span class="line">以上执行会创建 3 层镜像。可简化为以下格式：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 &amp;&amp; 符号连接命令，这样执行后，只会创建 1 层镜像</span></span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line">RUN yum install wget \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \</span><br><span class="line">    &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure>



<h3 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a>Dockerfile指令详解</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://pic-1256641195.cos.ap-nanjing.myqcloud.com/2020/10/dockerfile.png" alt="file"></p>
<h4 id="RUN-build时运行"><a href="#RUN-build时运行" class="headerlink" title="RUN - build时运行"></a><strong>RUN</strong> - build时运行</h4><p>用于执行后面跟着的命令行命令。有以下俩种格式：</p>
<ul>
<li>shell 格式</li>
<li>exec 格式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell 格式：</span></span><br><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"><span class="comment"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># exec 格式:</span></span><br><span class="line">RUN [<span class="string">"可执行文件"</span>, <span class="string">"参数1"</span>, <span class="string">"参数2"</span>]</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="comment"># RUN ["./test.php", "dev", "offline"] 等价于 RUN ./test.php dev offline</span></span><br></pre></td></tr></table></figure>

<h4 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h4><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="line">COPY [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="string">"&lt;源路径1&gt;"</span>,...  <span class="string">"&lt;目标路径&gt;"</span>]</span><br><span class="line"></span><br><span class="line">[--chown=&lt;user&gt;:&lt;group&gt;]：可选参数，用户改变复制到容器内文件的拥有者和属组。</span><br><span class="line"></span><br><span class="line">&lt;源路径&gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</span><br><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br><span class="line"></span><br><span class="line">&lt;目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</span><br></pre></td></tr></table></figure>

<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p>
<ul>
<li>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li>
<li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li>
</ul>
<h4 id="CMD-run时运行"><a href="#CMD-run时运行" class="headerlink" title="CMD - run时运行"></a>CMD - run时运行</h4><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>
<ul>
<li>CMD 在docker run 时运行。</li>
<li>RUN 是在 docker build。</li>
</ul>
<p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"></span><br><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [<span class="string">"&lt;可执行文件或命令&gt;"</span>,<span class="string">"&lt;param1&gt;"</span>,<span class="string">"&lt;param2&gt;"</span>,...] </span><br><span class="line">CMD [<span class="string">"&lt;param1&gt;"</span>,<span class="string">"&lt;param2&gt;"</span>,...]  <span class="comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br><span class="line"></span><br><span class="line">推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh</span><br></pre></td></tr></table></figure>



<blockquote>
<p>如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p>
</blockquote>
<h4 id="ENTRYPOINT-指定参数"><a href="#ENTRYPOINT-指定参数" class="headerlink" title="ENTRYPOINT - 指定参数"></a>ENTRYPOINT - 指定参数</h4><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>
<p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p>
<p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [<span class="string">"&lt;executeable&gt;"</span>,<span class="string">"&lt;param1&gt;"</span>,<span class="string">"&lt;param2&gt;"</span>,...]</span><br><span class="line">可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参</span><br></pre></td></tr></table></figure>

<p><strong>例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [<span class="string">"nginx"</span>, <span class="string">"-c"</span>] <span class="comment"># 定参</span></span><br><span class="line">CMD [<span class="string">"/etc/nginx/nginx.conf"</span>] <span class="comment"># 变参 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不传参运行</span></span><br><span class="line">$ docker run  nginx:<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 容器内会默认运行以下命令</span></span><br><span class="line">nginx -c /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传参运行  docker run时指定参数</span></span><br><span class="line">$ docker run  nginx:<span class="built_in">test</span> -c /etc/nginx/new.conf</span><br><span class="line"><span class="comment"># 容器内会默认运行以下命令</span></span><br><span class="line">nginx -c /etc/nginx/new.conf</span><br></pre></td></tr></table></figure>



<blockquote>
<p>如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>
</blockquote>
<h4 id="ENV-环境变量"><a href="#ENV-环境变量" class="headerlink" title="ENV - 环境变量"></a>ENV - 环境变量</h4><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;&#x3D;&lt;value1&gt; &lt;key2&gt;&#x3D;&lt;value2&gt;...</span><br></pre></td></tr></table></figure>

<p><strong>例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用</span></span><br><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> \</span><br><span class="line">  &amp;&amp; curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc"</span></span><br></pre></td></tr></table></figure>

<h4 id="ARG-build时的环境变量"><a href="#ARG-build时的环境变量" class="headerlink" title="ARG - build时的环境变量"></a>ARG - build时的环境变量</h4><p>构建参数，与 ENV 作用一至。</p>
<ul>
<li><p>不过作用域不一样。</p>
</li>
<li><p>ARG 设置的环境变量仅对 Dockerfile 内有效，</p>
<ul>
<li>也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</li>
</ul>
</li>
<li><p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"></span><br><span class="line">ARG &lt;参数名&gt;[=&lt;默认值&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="VOLUME-挂载点"><a href="#VOLUME-挂载点" class="headerlink" title="VOLUME - 挂载点"></a>VOLUME - 挂载点</h4><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<ul>
<li>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</li>
</ul>
<p>作用：</p>
<ul>
<li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li>
<li>避免容器不断变大。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"></span><br><span class="line">VOLUME [<span class="string">"&lt;路径1&gt;"</span>, <span class="string">"&lt;路径2&gt;"</span>...]</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure>

<h4 id="EXPOSE-端口"><a href="#EXPOSE-端口" class="headerlink" title="EXPOSE - 端口"></a>EXPOSE - 端口</h4><p>仅仅只是声明端口。</p>
<p>作用：</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br></pre></td></tr></table></figure>

<h4 id="WORKDIR-工作目录"><a href="#WORKDIR-工作目录" class="headerlink" title="WORKDIR - 工作目录"></a>WORKDIR - 工作目录</h4><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p>
<p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR &lt;工作目录路径&gt;</span><br></pre></td></tr></table></figure>

<h4 id="USER-用户"><a href="#USER-用户" class="headerlink" title="USER  - 用户"></a>USER  - 用户</h4><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER &lt;用户名&gt;[:&lt;用户组&gt;]</span><br></pre></td></tr></table></figure>

<h4 id="HEALTHCHECK-运行状态"><a href="#HEALTHCHECK-运行状态" class="headerlink" title="HEALTHCHECK - 运行状态"></a>HEALTHCHECK - 运行状态</h4><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</span><br><span class="line">HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span><br><span class="line"></span><br><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。</span><br></pre></td></tr></table></figure>

<h4 id="ONBUILD-延迟构建命令的执行"><a href="#ONBUILD-延迟构建命令的执行" class="headerlink" title="ONBUILD - 延迟构建命令的执行"></a>ONBUILD - 延迟构建命令的执行</h4><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD &lt;其它指令&gt;</span><br></pre></td></tr></table></figure>

<h2 id="五、Docker-Compose"><a href="#五、Docker-Compose" class="headerlink" title="五、Docker Compose"></a>五、Docker Compose</h2><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。</p>
<ul>
<li>通过 Compose，您可以使用 <code>YML 文件</code>来配置应用程序需要的所有服务。</li>
<li>然后，使用一个命令，就可以<strong>从 YML 文件配置中创建并启动所有服务</strong></li>
</ul>
<h3 id="Compose-使用的三个步骤："><a href="#Compose-使用的三个步骤：" class="headerlink" title="Compose 使用的三个步骤："></a><strong>Compose 使用的三个步骤：</strong></h3><ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yaml 配置实例</span></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">   - <span class="string">"5000:5000"</span></span><br><span class="line">    volumes:</span><br><span class="line">   - .:/code</span><br><span class="line">    - logvolume01:/var/<span class="built_in">log</span></span><br><span class="line">    links:</span><br><span class="line">   - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">volumes:</span><br><span class="line">  logvolume01: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Compose-安装"><a href="#Compose-安装" class="headerlink" title="Compose 安装"></a>Compose 安装</h3><p>Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的<a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">版本地址</a></p>
<ul>
<li>注意： 对于 alpine，需要以下依赖包： py-pip，python-dev，libffi-dev，openssl-dev，gcc，libc-dev，和 make。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要安装其他版本的 Compose，请替换 1.24.1</span></span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将可执行权限应用于二进制文件</span></span><br><span class="line">$ sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建软链：</span></span><br><span class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/bin/docker-compose /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试是否安装成功：</span></span><br><span class="line">$ docker-compose --version</span><br></pre></td></tr></table></figure>

<h3 id="Compose-实例"><a href="#Compose-实例" class="headerlink" title="Compose 实例"></a>Compose 实例</h3><ol>
<li><p>创建测试目录composetest： <code>mkdir composetest</code></p>
</li>
<li><p>在测试目录中创建一个名为 app.py 的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># composetest/app.py</span></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">import redis</span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># redis 是应用程序网络上的 redis 容器的主机名，该主机使用的端口为 6379</span></span><br><span class="line">cache = redis.Redis(host=<span class="string">'redis'</span>, port=6379)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_hit_count():</span><br><span class="line">    retries = 5</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        try:</span><br><span class="line">            <span class="built_in">return</span> cache.incr(<span class="string">'hits'</span>)</span><br><span class="line">        except redis.exceptions.ConnectionError as exc:</span><br><span class="line">            <span class="keyword">if</span> retries == 0:</span><br><span class="line">                raise exc</span><br><span class="line">            retries -= 1</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(<span class="string">'/'</span>)</span><br><span class="line">def hello():</span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'Hello World! I have been seen &#123;&#125; times.\n'</span>.format(count)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>在测试 目录中创建另一个名为 requirements.txt 的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 Dockerfile 文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7-alpine</span><br><span class="line"><span class="comment"># 将工作目录设置为 /code</span></span><br><span class="line">WORKDIR /code  </span><br><span class="line"><span class="comment"># 设置 flask 命令使用的环境变量</span></span><br><span class="line">ENV FLASK_APP app.py </span><br><span class="line">ENV FLASK_RUN_HOST 0.0.0.0</span><br><span class="line"><span class="comment"># 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。</span></span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line"><span class="comment"># 复制 requirements.txt 并安装 Python 依赖项</span></span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line"><span class="comment"># 将 . 项目中的当前目录复制到 . 镜像中的工作目录</span></span><br><span class="line">COPY . .</span><br><span class="line"><span class="comment"># 容器提供默认的执行命令为：flask run</span></span><br><span class="line">CMD [<span class="string">"flask"</span>, <span class="string">"run"</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 docker-compose.yml</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yaml 配置</span></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">"5000:5000"</span></span><br><span class="line">  redis:</span><br><span class="line">    image: <span class="string">"redis:alpine"</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义了两个服务：web 和 redis。</span></span><br><span class="line">web：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。</span><br><span class="line">redis：该 redis 服务使用 Docker Hub 的公共 Redis 映像。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 Compose 命令构建和运行您的应用</strong></p>
<ul>
<li>执行以下命令来启动应用程序：<code>docker-compose up</code></li>
</ul>
</li>
</ol>
<h3 id="yml-配置指令参考"><a href="#yml-配置指令参考" class="headerlink" title="yml 配置指令参考"></a>yml 配置指令参考</h3><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>指定本 yml 依从的 compose 哪个版本制定的。</p>
<h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定为构建镜像上下文路径：</p>
<p>例如 webapp 服务，指定为从上下文路径 ./dir/Dockerfile 所构建的镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: .&#x2F;dir</span><br></pre></td></tr></table></figure>

<p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: .&#x2F;dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br><span class="line">      labels:</span><br><span class="line">        - &quot;com.example.description&#x3D;Accounting webapp&quot;</span><br><span class="line">        - &quot;com.example.department&#x3D;Finance&quot;</span><br><span class="line">        - &quot;com.example.label-with-empty-value&quot;</span><br><span class="line">      target: prod</span><br></pre></td></tr></table></figure>

<ul>
<li>context：上下文路径。</li>
<li>dockerfile：指定构建镜像的 Dockerfile 文件名。</li>
<li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li>
<li>labels：设置构建镜像的标签。</li>
<li>target：多层构建，可以指定构建哪一层。</li>
</ul>
<h4 id="cap-add，cap-drop"><a href="#cap-add，cap-drop" class="headerlink" title="cap_add，cap_drop"></a>cap_add，cap_drop</h4><p>添加或删除容器拥有的宿主机的内核功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL # 开启全部权限</span><br><span class="line"></span><br><span class="line">cap_drop:</span><br><span class="line">  - SYS_PTRACE # 关闭 ptrace权限</span><br></pre></td></tr></table></figure>

<h4 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h4><p>为容器指定父 cgroup 组，意味着将继承该组的资源限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgroup_parent: m-executor-abcd</span><br></pre></td></tr></table></figure>

<h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>覆盖容器启动的默认命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p>指定自定义容器名称，而不是生成的默认名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: my-web-container</span><br></pre></td></tr></table></figure>

<h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>设置依赖关系。</p>
<ul>
<li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</li>
<li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</li>
<li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure>

<p>注意：web 服务不会等待 redis db 完全启动 之后才启动。</p>
<h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><p>指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      mode：replicated</span><br><span class="line">      replicas: 6</span><br><span class="line">      endpoint_mode: dnsrr</span><br><span class="line">      labels: </span><br><span class="line">        description: &quot;This redis service label&quot;</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#39;0.50&#39;</span><br><span class="line">          memory: 50M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: &#39;0.25&#39;</span><br><span class="line">          memory: 20M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br></pre></td></tr></table></figure>

<p>可以选参数：</p>
<p><strong>endpoint_mode</strong>：访问集群服务的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">endpoint_mode: vip </span><br><span class="line"># Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。</span><br><span class="line">endpoint_mode: dnsrr</span><br><span class="line"># DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。</span><br></pre></td></tr></table></figure>

<p><strong>labels</strong>：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。</p>
<p><strong>mode</strong>：指定服务提供的模式。</p>
<ul>
<li><strong>replicated</strong>：复制服务，复制指定服务到集群的机器上。</li>
<li><strong>global</strong>：全局服务，服务将部署至集群的每个节点。</li>
</ul>
<p><strong>replicas：mode</strong> 为 replicated 时，需要使用此参数配置具体运行的节点数量。</p>
<p><strong>resources</strong>：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。</p>
<p><strong>restart_policy</strong>：配置如何在退出容器时重新启动容器。</p>
<ul>
<li>condition：可选 none，on-failure 或者 any（默认值：any）。</li>
<li>delay：设置多久之后重启（默认值：0）。</li>
<li>max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。</li>
<li>window：设置容器重启超时时间（默认值：0）。</li>
</ul>
<p><strong>rollback_config</strong>：配置在更新失败的情况下应如何回滚服务。</p>
<ul>
<li>parallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。</li>
<li>delay：每个容器组回滚之间等待的时间（默认为0s）。</li>
<li>failure_action：如果回滚失败，该怎么办。其中一个 continue 或者 pause（默认pause）。</li>
<li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li>
<li>max_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。</li>
<li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。</li>
</ul>
<p><strong>update_config</strong>：配置应如何更新服务，对于配置滚动更新很有用。</p>
<ul>
<li>parallelism：一次更新的容器数。</li>
<li>delay：在更新一组容器之间等待的时间。</li>
<li>failure_action：如果更新失败，该怎么办。其中一个 continue，rollback 或者pause （默认：pause）。</li>
<li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li>
<li>max_failure_ratio：在更新过程中可以容忍的故障率。</li>
<li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认stop-first）。</li>
</ul>
<p><strong>注</strong>：仅支持 V3.4 及更高版本。</p>
<h4 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h4><p>指定设备映射列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - &quot;&#x2F;dev&#x2F;ttyUSB0:&#x2F;dev&#x2F;ttyUSB0&quot;</span><br></pre></td></tr></table></figure>

<h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h4><p>自定义 DNS 服务器，可以是单个值或列表的多个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 9.9.9.9</span><br></pre></td></tr></table></figure>

<h4 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h4><p>自定义 DNS 搜索域。可以是单个值或列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - dc1.example.com</span><br><span class="line">  - dc2.example.com</span><br></pre></td></tr></table></figure>

<h4 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h4><p>覆盖容器默认的 entrypoint。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entrypoint: &#x2F;code&#x2F;entrypoint.sh</span><br></pre></td></tr></table></figure>

<p>也可以是以下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entrypoint:</span><br><span class="line">    - php</span><br><span class="line">    - -d</span><br><span class="line">    - zend_extension&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20100525&#x2F;xdebug.so</span><br><span class="line">    - -d</span><br><span class="line">    - memory_limit&#x3D;-1</span><br><span class="line">    - vendor&#x2F;bin&#x2F;phpunit</span><br></pre></td></tr></table></figure>

<h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>从文件添加环境变量。可以是单个值或列表的多个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br></pre></td></tr></table></figure>

<p>也可以是列表格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env_file:</span><br><span class="line">  - .&#x2F;common.env</span><br><span class="line">  - .&#x2F;apps&#x2F;web.env</span><br><span class="line">  - &#x2F;opt&#x2F;secrets.env</span><br></pre></td></tr></table></figure>

<h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: &#39;true&#39;</span><br></pre></td></tr></table></figure>

<h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure>

<h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><p>添加主机名映射。类似 docker client –add-host。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;somehost:162.242.195.82&quot;</span><br><span class="line"> - &quot;otherhost:50.31.209.229&quot;</span><br></pre></td></tr></table></figure>

<p>以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">162.242.195.82  somehost</span><br><span class="line">50.31.209.229   otherhost</span><br></pre></td></tr></table></figure>

<h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>用于检测 docker 服务是否健康运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost&quot;] # 设置检测程序</span><br><span class="line">  interval: 1m30s # 设置检测间隔</span><br><span class="line">  timeout: 10s # 设置检测超时时间</span><br><span class="line">  retries: 3 # 设置重试次数</span><br><span class="line">  start_period: 40s # 启动后，多少秒开始启动检测程序</span><br></pre></td></tr></table></figure>

<h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定容器运行的镜像。以下格式都可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image: redis</span><br><span class="line">image: ubuntu:14.04</span><br><span class="line">image: tutum&#x2F;influxdb</span><br><span class="line">image: example-registry.com:4000&#x2F;postgresql</span><br><span class="line">image: a4bc65fd # 镜像id</span><br></pre></td></tr></table></figure>

<h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>服务的日志记录配置。</p>
<p>driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure>

<p>仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: json-file</span><br><span class="line">  options:</span><br><span class="line">    max-size: &quot;200k&quot; # 单个文件大小为200k</span><br><span class="line">    max-file: &quot;10&quot; # 最多10个文件</span><br></pre></td></tr></table></figure>

<p>当达到文件限制上限，会自动删除旧得文件。</p>
<p>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp:&#x2F;&#x2F;192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure>

<h4 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h4><p>设置网络模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name&#x2F;id]&quot;</span><br></pre></td></tr></table></figure>

<p>networks</p>
<p>配置容器连接的网络，引用顶级 networks 下的条目 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">      some-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias1</span><br><span class="line">      other-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias2</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  other-network:</span><br><span class="line">    # Use a custom driver which takes special options</span><br><span class="line">    driver: custom-driver-2</span><br></pre></td></tr></table></figure>

<p><strong>aliases</strong> ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。</p>
<h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h4><ul>
<li>no：是默认的重启策略，在任何情况下都不会重启容器。</li>
<li>always：容器总是重新启动。</li>
<li>on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</li>
<li>unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restart: &quot;no&quot;</span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure>

<p>注：swarm 集群模式，请改用 restart_policy。</p>
<h4 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h4><p>存储敏感数据，例如密码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: &#x2F;run&#x2F;secrets&#x2F;my_secret</span><br><span class="line">  secrets:</span><br><span class="line">    - my_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: .&#x2F;my_secret.txt</span><br></pre></td></tr></table></figure>

<h4 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a>security_opt</h4><p>修改容器默认的 schema 标签。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">security-opt：</span><br><span class="line">  - label:user:USER   # 设置容器的用户标签</span><br><span class="line">  - label:role:ROLE   # 设置容器的角色标签</span><br><span class="line">  - label:type:TYPE   # 设置容器的安全策略标签</span><br><span class="line">  - label:level:LEVEL  # 设置容器的安全等级标签</span><br></pre></td></tr></table></figure>

<h4 id="stop-grace-period"><a href="#stop-grace-period" class="headerlink" title="stop_grace_period"></a>stop_grace_period</h4><p>指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop_grace_period: 1s # 等待 1 秒</span><br><span class="line">stop_grace_period: 1m30s # 等待 1 分 30 秒</span><br></pre></td></tr></table></figure>

<p>默认的等待时间是 10 秒。</p>
<h4 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h4><p>设置停止容器的替代信号。默认情况下使用 SIGTERM 。</p>
<p>以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop_signal: SIGUSR1</span><br></pre></td></tr></table></figure>

<h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h4><p>设置容器中的内核参数，可以使用数组或字典格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn&#x3D;1024</span><br><span class="line">  - net.ipv4.tcp_syncookies&#x3D;0</span><br></pre></td></tr></table></figure>

<h4 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h4><p>在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmpfs: &#x2F;run</span><br><span class="line"></span><br><span class="line">tmpfs:</span><br><span class="line">  - &#x2F;run</span><br><span class="line">  - &#x2F;tmp</span><br></pre></td></tr></table></figure>

<h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h4><p>覆盖容器默认的 ulimit。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure>

<h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>将主机的数据卷或着文件挂载到容器里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;localhost&#x2F;postgres.sock:&#x2F;var&#x2F;run&#x2F;postgres&#x2F;postgres.sock&quot;</span><br><span class="line">      - &quot;&#x2F;localhost&#x2F;data:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&quot;</span><br></pre></td></tr></table></figure>

<h2 id="六、Docker-Machine"><a href="#六、Docker-Machine" class="headerlink" title="六、Docker Machine"></a>六、Docker Machine</h2><p>Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。</p>
<ul>
<li>使用不同引擎在多种平台上快速的安装Docker环境，<a href="https://github.com/docker/machine" target="_blank" rel="noopener">开源地址</a></li>
<li>Docker Machine 也可以集中管理所有的 docker 主机，比如快速的给 100 台服务器安装上 docker。</li>
<li>Docker Machine 是一个工具，它允许你在虚拟宿主机上安装Docker，并使用docker-machine命令管理这个宿主机，<ul>
<li>可以使用Docker Machine在本地的MAC或者windows box、公司网络，数据中心或者AWS这样的云提供商上创建docker</li>
</ul>
</li>
<li>使用 docker-machine 命令，可以启动，检查，停止和重新启动托管主机，也可以升级 Docker 客户端和守护程序，以及配置 Docker 客户端与您的主机进行通信。</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 Docker Machine 之前你需要先安装 Docker。</p>
<p>Docker Mechine 可以在多种平台上安装使用，包括 Linux 、MacOS 以及 windows</p>
<ul>
<li>　Docker Mechine 安装非常的简单：GitHub<a href="https://github.com/docker/machine/releases/" target="_blank" rel="noopener">地址</a> 里面有安装教程</li>
</ul>
<h4 id="Linux-安装命令"><a href="#Linux-安装命令" class="headerlink" title="Linux 安装命令"></a>Linux 安装命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;</span><br><span class="line">  curl -L <span class="variable">$base</span>/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp;</span><br><span class="line">  sudo mv /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine &amp;&amp;</span><br><span class="line">  chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</span><br></pre></td></tr></table></figure>

<h4 id="macOS-安装命令"><a href="#macOS-安装命令" class="headerlink" title="macOS 安装命令"></a>macOS 安装命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;</span><br><span class="line">  curl -L <span class="variable">$base</span>/docker-machine-$(uname -s)-$(uname -m) &gt;/usr/<span class="built_in">local</span>/bin/docker-machine &amp;&amp;</span><br><span class="line">  chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</span><br></pre></td></tr></table></figure>

<p>查看是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine version</span><br><span class="line">docker-machine version 0.16.0, build 9371605</span><br></pre></td></tr></table></figure>

<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><p>所有命令前加 <strong>docker-machine</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>active</td>
<td>查看当前激活状态的Docker主机</td>
</tr>
<tr>
<td>config</td>
<td>查看当前激活状态Docker主机的连接信息</td>
</tr>
<tr>
<td>creat</td>
<td>创建Docker主机</td>
</tr>
<tr>
<td>env</td>
<td>显示连接到某个主机需要的环境变量</td>
</tr>
<tr>
<td>inspect</td>
<td>以json格式输出指定Docker的详细信息</td>
</tr>
<tr>
<td>ip</td>
<td>获取指定Docker主机的地址</td>
</tr>
<tr>
<td>kill</td>
<td>直接杀死指定的Docker主机</td>
</tr>
<tr>
<td>ls</td>
<td>列出所有的管理主机</td>
</tr>
<tr>
<td>provision</td>
<td>重新配置指定主机</td>
</tr>
<tr>
<td>regenerate-certs</td>
<td>为某个主机重新生成TLS信息</td>
</tr>
<tr>
<td>restart</td>
<td>重启指定的主机</td>
</tr>
<tr>
<td>rm</td>
<td>删除某台Docker主机，对应的虚拟机也会被删除</td>
</tr>
<tr>
<td>ssh</td>
<td>通过SSH连接到主机上，执行命令</td>
</tr>
<tr>
<td>scp</td>
<td>在Docker主机之间以及Docker主机和本地主机之间通过scp远程复制数据</td>
</tr>
<tr>
<td>mount</td>
<td>使用SSHFS从计算机装载或卸载目录</td>
</tr>
<tr>
<td>start</td>
<td>启动一个指定的Docker主机，如果对象是个虚拟机，该虚拟机将被启动</td>
</tr>
<tr>
<td>status</td>
<td>获取指定Docker主机的状态(包括：Running、Paused、Saved、Stopped、Stopping、Starting、Error)等</td>
</tr>
<tr>
<td>stop</td>
<td>停止一个指定的Docker主机</td>
</tr>
<tr>
<td>upgrade</td>
<td>将一个指定主机的Docker版本更新为最新</td>
</tr>
<tr>
<td>url</td>
<td>获取指定Docker主机的监听URL</td>
</tr>
<tr>
<td>version</td>
<td>显示Docker Machine的版本或者主机Docker版本</td>
</tr>
<tr>
<td>help</td>
<td>显示帮助信息</td>
</tr>
</tbody></table>
<h2 id="七、Docker-Swarm-集群管理"><a href="#七、Docker-Swarm-集群管理" class="headerlink" title="七、Docker Swarm  集群管理"></a>七、Docker Swarm  集群管理</h2><p>Docker Swarm 是 Docker 的集群管理工具。</p>
<ul>
<li>它将 Docker 主机池转变为单个虚拟 Docker 主机。 </li>
<li>Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机。</li>
</ul>
<p>支持的工具包括但不限于以下各项：</p>
<ul>
<li>Dokku</li>
<li>Docker Compose</li>
<li>Docker Machine</li>
<li>Jenkins</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>swarm 集群由管理节点（manager）和工作节点（work node）构成。</p>
<ul>
<li><strong>swarm mananger</strong>：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。</li>
<li><strong>work node</strong>：即图中的 available node，主要负责运行相应的服务来执行任务（task）</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://pic-1256641195.cos.ap-nanjing.myqcloud.com/2020/10/services-diagram.png" alt="jq"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建 swarm 集群管理节点（manager）</span></span><br><span class="line"><span class="comment">## 创建 docker 机器：</span></span><br><span class="line">$ docker-machine create -d virtualbox swarm-manager</span><br><span class="line"><span class="comment">## 初始化 swarm 集群，进行初始化的这台机器，就是集群的管理节点</span></span><br><span class="line">$ docker-machine ssh swarm-manager</span><br><span class="line">$ docker swarm init --advertise-addr 192.168.99.107 <span class="comment">#这里的 IP 为创建机器时分配的 ip。</span></span><br><span class="line"></span><br><span class="line">docker swarm join --token SWMTKN-1-4oogo9qziq768dma0uh3j0z0m5twlm10iynvz7ixza96k6jh9p-ajkb6w7qd06y1e33yrgko64sk 192.168.99.107:2377</span><br><span class="line">以上输出，证明已经初始化成功。需要把这行复制出来，在增加工作节点时会用到</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.创建 swarm 集群工作节点（worker）</span></span><br><span class="line">这里直接创建好俩台机器，swarm-worker1 和 swarm-worker2 </span><br><span class="line"></span><br><span class="line">分别进入两个机器里，指定添加至上一步中创建的集群</span><br><span class="line">docker-machine ssh swarm-worker1</span><br><span class="line">docker-machine ssh swarm-worker2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看集群信息</span></span><br><span class="line"><span class="comment">#进入管理节点，执行：docker info 可以查看当前集群的信息。</span></span><br><span class="line">$ docker info</span><br><span class="line">显示中可以知道当前运行的集群中，有三个节点，其中有一个是管理节点</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.部署服务到集群中</span></span><br><span class="line">注意：跟集群管理有关的任何操作，都是在管理节点上操作的</span><br><span class="line"><span class="comment"># 在一个工作节点上创建一个名为 helloworld 的服务，这里是随机指派给一个工作节点</span></span><br><span class="line">$ docker service create --replicas 1 --name helloworld alpine ping docker.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.查看服务部署情况</span></span><br><span class="line"><span class="comment">#查看 helloworld 服务运行在哪个节点上，可以看到目前是在 swarm-worker1 节点</span></span><br><span class="line">$ docker service ps helloworld</span><br><span class="line"><span class="comment"># 查看 helloworld 部署的具体信息</span></span><br><span class="line">$ docker service inspect --pretty helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.扩展集群服务</span></span><br><span class="line"><span class="comment">#将上述的 helloworld 服务扩展到俩个节点。</span></span><br><span class="line">$ docker service scale helloworld=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.删除服务</span></span><br><span class="line">$ docker service rm helloworld</span><br><span class="line"><span class="comment"># 查看是否已删除</span></span><br><span class="line">$ docker service ps helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.滚动升级服务</span></span><br><span class="line"><span class="comment"># 创建一个 3.0.6 版本的 redis</span></span><br><span class="line">$ docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6</span><br><span class="line"><span class="comment"># 滚动升级 redis </span></span><br><span class="line">$ docker service update --image redis:3.0.7 redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.停止某个节点接收新的任务</span></span><br><span class="line"><span class="comment">#查看所有的节点</span></span><br><span class="line">$ docker node ls</span><br><span class="line"><span class="comment"># 可以看到目前所有的节点都是 Active, 可以接收新的任务分配</span></span><br><span class="line"><span class="comment"># 停止节点 swarm-worker1</span></span><br><span class="line">$  docker node update --availability active swarm-worker1</span><br></pre></td></tr></table></figure>



<h2 id="八、命令大全"><a href="#八、命令大全" class="headerlink" title="八、命令大全"></a>八、命令大全</h2><h3 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h3><ul>
<li><a href="https://www.runoob.com/docker/docker-run-command.html" target="_blank" rel="noopener">run</a></li>
<li><a href="https://www.runoob.com/docker/docker-start-stop-restart-command.html" target="_blank" rel="noopener">start/stop/restart</a></li>
<li><a href="https://www.runoob.com/docker/docker-kill-command.html" target="_blank" rel="noopener">kill</a></li>
<li><a href="https://www.runoob.com/docker/docker-rm-command.html" target="_blank" rel="noopener">rm</a></li>
<li><a href="https://www.runoob.com/docker/docker-pause-unpause-command.html" target="_blank" rel="noopener">pause/unpause</a></li>
<li><a href="https://www.runoob.com/docker/docker-create-command.html" target="_blank" rel="noopener">create</a></li>
<li><a href="https://www.runoob.com/docker/docker-exec-command.html" target="_blank" rel="noopener">exec</a></li>
</ul>
<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><ul>
<li><a href="https://www.runoob.com/docker/docker-ps-command.html" target="_blank" rel="noopener">ps</a></li>
<li><a href="https://www.runoob.com/docker/docker-inspect-command.html" target="_blank" rel="noopener">inspect</a></li>
<li><a href="https://www.runoob.com/docker/docker-top-command.html" target="_blank" rel="noopener">top</a></li>
<li><a href="https://www.runoob.com/docker/docker-attach-command.html" target="_blank" rel="noopener">attach</a></li>
<li><a href="https://www.runoob.com/docker/docker-events-command.html" target="_blank" rel="noopener">events</a></li>
<li><a href="https://www.runoob.com/docker/docker-logs-command.html" target="_blank" rel="noopener">logs</a></li>
<li><a href="https://www.runoob.com/docker/docker-wait-command.html" target="_blank" rel="noopener">wait</a></li>
<li><a href="https://www.runoob.com/docker/docker-export-command.html" target="_blank" rel="noopener">export</a></li>
<li><a href="https://www.runoob.com/docker/docker-port-command.html" target="_blank" rel="noopener">port</a></li>
</ul>
<h3 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h3><ul>
<li><a href="https://www.runoob.com/docker/docker-commit-command.html" target="_blank" rel="noopener">commit</a></li>
<li><a href="https://www.runoob.com/docker/docker-cp-command.html" target="_blank" rel="noopener">cp</a></li>
<li><a href="https://www.runoob.com/docker/docker-diff-command.html" target="_blank" rel="noopener">diff</a></li>
</ul>
<h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><ul>
<li><a href="https://www.runoob.com/docker/docker-login-command.html" target="_blank" rel="noopener">login</a></li>
<li><a href="https://www.runoob.com/docker/docker-pull-command.html" target="_blank" rel="noopener">pull</a></li>
<li><a href="https://www.runoob.com/docker/docker-push-command.html" target="_blank" rel="noopener">push</a></li>
<li><a href="https://www.runoob.com/docker/docker-search-command.html" target="_blank" rel="noopener">search</a></li>
</ul>
<h3 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h3><ul>
<li><a href="https://www.runoob.com/docker/docker-images-command.html" target="_blank" rel="noopener">images</a></li>
<li><a href="https://www.runoob.com/docker/docker-rmi-command.html" target="_blank" rel="noopener">rmi</a></li>
<li><a href="https://www.runoob.com/docker/docker-tag-command.html" target="_blank" rel="noopener">tag</a></li>
<li><a href="https://www.runoob.com/docker/docker-build-command.html" target="_blank" rel="noopener">build</a></li>
<li><a href="https://www.runoob.com/docker/docker-history-command.html" target="_blank" rel="noopener">history</a></li>
<li><a href="https://www.runoob.com/docker/docker-save-command.html" target="_blank" rel="noopener">save</a></li>
<li><a href="https://www.runoob.com/docker/docker-load-command.html" target="_blank" rel="noopener">load</a></li>
<li><a href="https://www.runoob.com/docker/docker-import-command.html" target="_blank" rel="noopener">import</a></li>
</ul>
<h3 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h3><ul>
<li><a href="https://www.runoob.com/docker/docker-info-command.html" target="_blank" rel="noopener">info</a></li>
<li><a href="https://www.runoob.com/docker/docker-version-command.html" target="_blank" rel="noopener">version</a></li>
</ul>
<h2 id="九、其他问题"><a href="#九、其他问题" class="headerlink" title="九、其他问题"></a>九、其他问题</h2><h3 id="镜像中安装VIM、yum"><a href="#镜像中安装VIM、yum" class="headerlink" title="镜像中安装VIM、yum"></a>镜像中安装VIM、yum</h3><p>使用VIM，提示 <code>bash: vi: command not found</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install vim yum</span><br><span class="line"></span><br><span class="line"><span class="comment">#没错，即使你是CentOS，也可以用apt-get</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装其他</span></span><br><span class="line"><span class="comment">#安装ifconfig</span></span><br><span class="line">apt-get install net-tools</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装ping</span></span><br><span class="line">apt-get install inetutils-ping</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装telnet</span></span><br><span class="line">apt-get install telnet</span><br></pre></td></tr></table></figure>

<p>若下载慢，配置国内镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://mirrors.163.com/debian/ jessie main non-free contrib"</span> &gt;/etc/apt/sources.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib"</span> &gt;&gt;/etc/apt/sources.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb-src http://mirrors.163.com/debian/ jessie main non-free contrib"</span> &gt;&gt;/etc/apt/sources.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb-src http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib"</span> &gt;&gt;/etc/apt/sources.list</span><br><span class="line"><span class="comment">#更新安装源</span></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure>





<blockquote>
<p>参考：</p>
<p><a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<p><a href="http://jartto.wang/2020/07/04/learn-docker/" target="_blank" rel="noopener">Docker 边学边用</a></p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Gkon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gxkon.top/posts/c93c8bf/">http://gxkon.top/posts/c93c8bf/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gxkon.top" target="_blank">Gxkon's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post_share"><div class="social-share" data-image="/Pic/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/posts/263918de/"><img class="prev_cover" data-src="/Pic/post.jpg" onerror="onerror=null;src='/Pic/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python之读取yaml配置文件</div></div></a></div><div class="next-post pull_right"><a href="/posts/e7e52c2a/"><img class="next_cover" data-src="/Pic/post.jpg" onerror="onerror=null;src='/Pic/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker简易封装Flask  +Gunicorn</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/e7e52c2a/" title="Docker简易封装Flask  +Gunicorn"><img class="relatedPosts_cover" data-src="/Pic/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-10-05</div><div class="relatedPosts_title">Docker简易封装Flask  +Gunicorn</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '1ce3148e3133bf004c96',
  clientSecret: '2a1e5c0f4d38387460b916843bfe5cac67ef2d07',
  repo: 'blankwz.github.io',
  owner: 'blankwz',
  admin: ['blankwz'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Gkon</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/third-party/ClickShowText.js"></script></body></html>